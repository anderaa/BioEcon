popMatrix[dogNumber, 'sterilized'] <- 1
dailySpending <- dailySpending + as.numeric(strategyCostVector['sterPuppyMale'])
}
} else if (strategyVector['contraPuppyMale'] == 1) {
if (popMatrix[dogNumber, 'sterilized'] == 0) {
# we won't contracept if dog has been sterilized, be we will even if already contracepted
popMatrix[dogNumber, 'contracepted'] <- 1
popMatrix[dogNumber, 'timeContra'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['contraPuppyMale'])
}
}
if (strategyVector['vaccPuppyMale'] == 1) {
if (popMatrix[dogNumber, 'vaccinated'] == 0) {
popMatrix[dogNumber, 'vaccinated'] <- 1
popMatrix[dogNumber, 'timeVacc'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['vaccPuppyMale'])
} else if (boosterGiven == TRUE) {
popMatrix[dogNumber, 'vaccinated'] <- 1
popMatrix[dogNumber, 'boosted'] <- 1
popMatrix[dogNumber, 'timeVacc'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['vaccPuppyMale'])
}
}
}
} else if (popMatrix[dogNumber, 'adult'] == 1) {
# male ADULT management here
if (strategyVector['euthAdultMale'] == 1) {
popMatrix <- popMatrix[!dogNumber, , drop=FALSE]
dailySpending <- dailySpending + as.numeric(strategyCostVector['euthAdultMale'])
} else {
if (strategyVector['sterAdultMale'] == 1) {
if (popMatrix[dogNumber, 'sterilized'] == 0) {
popMatrix[dogNumber, 'sterilized'] <- 1
dailySpending <- dailySpending + as.numeric(strategyCostVector['sterAdultMale'])
}
} else if (strategyVector['contraAdultMale'] == 1) {
if (popMatrix[dogNumber, 'sterilized'] == 0) {
# we won't contracept if dog has been sterilized, be we will even if already contracepted
popMatrix[dogNumber, 'contracepted'] <- 1
popMatrix[dogNumber, 'timeContra'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['contraAdultMale'])
}
}
if (strategyVector['vaccAdultMale'] == 1) {
if (popMatrix[dogNumber, 'vaccinated'] == 0) {
popMatrix[dogNumber, 'vaccinated'] <- 1
popMatrix[dogNumber, 'timeVacc'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['vaccAdultMale'])
} else if (boosterGiven == TRUE) {
popMatrix[dogNumber, 'vaccinated'] <- 1
popMatrix[dogNumber, 'boosted'] <- 1
popMatrix[dogNumber, 'timeVacc'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['vaccAdultMale'])
}
}
}
} else {
# male JUVENILE management here
if (strategyVector['euthJuvMale'] == 1) {
popMatrix <- popMatrix[!dogNumber, , drop=FALSE]
dailySpending <- dailySpending + as.numeric(strategyCostVector['euthJuvMale'])
} else {
if (strategyVector['sterJuvMale'] == 1) {
if (popMatrix[dogNumber, 'sterilized'] == 0) {
popMatrix[dogNumber, 'sterilized'] <- 1
dailySpending <- dailySpending + as.numeric(strategyCostVector['sterJuvMale'])
}
} else if (strategyVector['contraJuvMale'] == 1) {
if (popMatrix[dogNumber, 'sterilized'] == 0) {
# we won't contracept if dog has been sterilized, be we will even if already contracepted
popMatrix[dogNumber, 'contracepted'] <- 1
popMatrix[dogNumber, 'timeContra'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['contraJuvMale'])
}
}
if (strategyVector['vaccJuvMale'] == 1) {
if (popMatrix[dogNumber, 'vaccinated'] == 0) {
popMatrix[dogNumber, 'vaccinated'] <- 1
popMatrix[dogNumber, 'timeVacc'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['vaccJuvMale'])
} else if (boosterGiven == TRUE) {
popMatrix[dogNumber, 'vaccinated'] <- 1
popMatrix[dogNumber, 'boosted'] <- 1
popMatrix[dogNumber, 'timeVacc'] <- 0
dailySpending <- dailySpending + as.numeric(strategyCostVector['vaccJuvMale'])
}
}
}
}
}
}
}
return(list(popMatrix, totalContacted, dailySpending))
}
########################################################################################################################
########################################################################################################################
CensusFunction <- function() {
# Arguments: None.
# Return: A vector of results.
# Purpose: Calculate results that are recorded daily.
censusVector['abundance'] <- nrow(popMatrix)
censusVector['puppy'] <- sum(popMatrix[, 'age'] <= maxPuppyAge)
censusVector['adult'] <- sum(popMatrix[, 'age'] > maxJuvAge)
censusVector['females'] <- sum(popMatrix[, 'female'])
censusVector['sterilized'] <- sum(popMatrix[, 'sterilized'])
censusVector['femalesSterilized'] <- sum(popMatrix[, 'sterilized'] == 1 & popMatrix[, 'female'] == 1)
censusVector['contracepted'] <- sum(popMatrix[, 'sterilized'])
censusVector['femalesContracepted'] <- sum(popMatrix[, 'contracepted'] == 1 &
popMatrix[, 'female'] == 1)
censusVector['vaccinated'] <- sum(popMatrix[, 'vaccinated'])
censusVector['immune'] <- sum(popMatrix[, 'immune'])
censusVector['exposed'] <- sum(popMatrix[, 'exposed'])
censusVector['infective'] <- sum(popMatrix[, 'infective'])
bitesNonRabid <- bitesPerNonRabid * (censusVector['abundance'] - censusVector['infective'])
bitesRabid <- bitesPerRabid * (censusVector['infective'])
censusVector['PEPs'] <- PEPperNonRabidBite * bitesNonRabid + PEPperRabidBite * bitesRabid
censusVector['lifeLoss'] <- lifeLossPerRabidBite * ((1 - PEPperRabidBite) * bitesRabid)
return(censusVector)
}
########################################################################################################################
########################################################################################################################
TimeFunction <- function() {
# Arguments: None.
# Return:    An updated population matrix.
# Purpose:   Updates time-related columns in the population matrix.
if (boosterGiven == FALSE) {
# Turn off vaccinated and contracepted when time limit reached:
popMatrix[popMatrix[, 'timeVacc'] == timeVaccineEffective, 'vaccinated'] <- 0
popMatrix[(popMatrix[, 'timeContra'] == timeContraEffectiveFemales & popMatrix[, 'female'] == 1),
'contracepted'] <- 0
popMatrix[(popMatrix[, 'timeContra'] == timeContraEffectiveMales & popMatrix[, 'female'] == 0),
'contracepted'] <- 0
} else {
# Turn off vaccinated when time limit reached:
popMatrix[(popMatrix[, 'timeVacc'] == timeVaccineEffective & popMatrix[, 'boosted'] == 0), 'vaccinated'] <- 0
# Turn off boosted and vaccinated when time limit reached:
popMatrix[(popMatrix[, 'timeVacc'] == timeBoosterEffective & popMatrix[, 'boosted'] == 1), 'vaccinated'] <- 0
popMatrix[(popMatrix[, 'timeVacc'] == timeBoosterEffective & popMatrix[, 'boosted'] == 1), 'boosted'] <- 0
# Turn off contracepted when time limit reached:
popMatrix[(popMatrix[, 'timeContra'] == timeContraEffectiveFemales & popMatrix[, 'female'] == 1),
'contracepted'] <- 0
popMatrix[(popMatrix[, 'timeContra'] == timeContraEffectiveMales & popMatrix[, 'female'] == 0),
'contracepted'] <- 0
}
popMatrix[, 'age']           <- popMatrix[, 'age'] + 1
popMatrix[, 'timeVacc']      <- popMatrix[, 'timeVacc'] + 1
popMatrix[, 'timeContra']    <- popMatrix[, 'timeContra'] + 1
popMatrix[, 'timeExposed']   <- popMatrix[, 'timeExposed'] + 1
popMatrix[, 'timeInfective'] <- popMatrix[, 'timeInfective'] + 1
return(popMatrix)
}
########################################################################################################################
########################################################################################################################
# This is the loop that reads in the parameter values from each of the simulations presented in the paper.
# It adds the results of each to the parameter_df, then writes it back to disk when finished.
parameter_df <- read.csv('Manuscript_Scenarios_Cost.csv', stringsAsFactors=FALSE)
parameter_df['dog_days'] <- NA
parameter_df['prob_outbreak'] <- NA
parameter_df['max_prev'] <- NA
parameter_df['max_vacc'] <- NA
parameter_df['total_cost'] <- NA
for(k in seq(1, nrow(parameter_df))) {
# inputs for simulation
simulationYears <- 5
simulationEnd   <- 365 * simulationYears
iterations      <- 5
# inputs for initial population
initialPopSize    <- 463
initialFracAdult  <- 0.61
initialFracPup    <- 0.33
initialFracFemale <- 0.38
initialFracImmune <- 0.0
initialFracContra <- 0.0
initialFracVacc   <- 0.0
initialFracSter   <- 0.0
# inputs for mortality
maxJuvAge          <- 299
maxPuppyAge        <- 89
maxAge             <- 4000
carryingCap        <- 577
pupAnnMortProb     <- 0.90
juvAnnMortProb     <- 0.63
adultAnnMortProb   <- 0.32
emigrationProb     <- 0
# inputs for reproduction
immigrantDogs        <- 131
expectedLittersPFY   <- 0.31
expLitterPer <- expectedLittersPFY
meanLitterSize       <- 4.4
femalePupProb        <- 0.38
fractionBirthPulse   <- 0.0
birthPulseVector     <- rep(0, 12)
birthPulseVector[1]  <- 0
birthPulseVector[2]  <- 0
birthPulseVector[3]  <- 0
birthPulseVector[4]  <- 0
birthPulseVector[5]  <- 0
birthPulseVector[6]  <- 0
birthPulseVector[7]  <- 0
birthPulseVector[8]  <- 0
birthPulseVector[9]  <- 0
birthPulseVector[10] <- 0
birthPulseVector[11] <- 0
birthPulseVector[12] <- 0
# inputs for disease
monthsOfPressure      <- 1
dogsPerMonthExposed   <- 1
monthInitIntroduction <- 25
transmissionParam     <- 2.15 * parameter_df[k, 'bite_scale']
bitesPerRabidMean <- transmissionParam
bitesPerRabidShape    <- 1.33
probInfectionFromBite <- 0.49
survivalProb          <- 0
exposedTimeShape      <- 1.08549138
exposedTimeRate       <- 0.04919551
infectiveTimeShape    <- 2.831788
infectiveTimeRate     <- 0.9193612
# inputs for benefits of management
bitesPerNonRabid     <- 0.00017/3
bitesPerRabid        <- 0.06756/3
PEPperNonRabidBite   <- 0.991
PEPperRabidBite      <- 0.991
costPerPEP           <- 754.92
lifeLossPerRabidBite <- 0.19
# inputs for treatment costs
vaccineCost             <- 2.426
contraceptionCostFemale <- 150
contraceptionCostMale   <- 150
sterilizationCostFemale <- 300
sterilizationCostMale   <- 200
euthanasiaCost          <- 150
# inputs for effectiveness of contraception and vaccination
timeVaccineEffective       <- 730
timeBoosterEffective       <- 1095
timeContraEffectiveMales   <- 730
timeContraEffectiveFemales <- 730
# inputs for contact costs
# note: 25, 50, 75, 100, mean 25% 50%, 75%, 100% of specified
#       initial abundance
contactCost25  <- 1019.09 * parameter_df[k, 'contact_cost_scale']
contactCost50  <- 2757.3 * parameter_df[k, 'contact_cost_scale']
contactCost75  <- 4735.89 * parameter_df[k, 'contact_cost_scale']
contactCost100 <- 8453.7 * parameter_df[k, 'contact_cost_scale']
# input for budget years 1-5
annualBudget     <- rep(0, simulationYears)
if (parameter_df[k, 'timing'] == 'annual') {
annualBudget[1]  <- parameter_df[k, 'budget'] / 5
annualBudget[2]  <- parameter_df[k, 'budget'] / 5
annualBudget[3]  <- parameter_df[k, 'budget'] / 5
annualBudget[4]  <- parameter_df[k, 'budget'] / 5
annualBudget[5]  <- parameter_df[k, 'budget'] / 5
}
if (parameter_df[k, 'timing'] == 'biennial') {
annualBudget[1]  <- parameter_df[k, 'budget'] / 3
annualBudget[2]  <- 0
annualBudget[3]  <- parameter_df[k, 'budget'] / 3
annualBudget[4]  <- 0
annualBudget[5]  <- parameter_df[k, 'budget'] / 3
}
if (parameter_df[k, 'timing'] == 'reactive') {
annualBudget[1]  <- 0
annualBudget[2]  <- 0
annualBudget[3]  <- parameter_df[k, 'budget'] / 3
annualBudget[4]  <- parameter_df[k, 'budget'] / 3
annualBudget[5]  <- parameter_df[k, 'budget'] / 3
}
# inputs for strategy
# note: model assumes already sterilized dogs are not re-sterilized.
#       Within the same year dogs will not be vaccinated or contracepted
#       twice. If dogs are re-contancted in a future year, they will be
#       re-vaccinated or re-contracepted
# note: contraception and sterilization cannot both equal 1 for same
#       demographic
# note: if euthanisia equal 1 for some demographic,
#       all other treatments must equal zero
vaccPuppyMale     <- parameter_df[k, 'puppy_vac']
vaccPuppyFemale   <- parameter_df[k, 'puppy_vac']
vaccAdultMale     <- 1
vaccAdultFemale   <- 1
vaccJuvMale       <- 1
vaccJuvFemale     <- 1
contraPuppyMale   <- 0
contraPuppyFemale <- 0
contraAdultMale   <- 0
contraAdultFemale <- 0
contraJuvMale     <- 0
contraJuvFemale   <- 0
sterPuppyMale     <- 0
sterPuppyFemale   <- 0
sterAdultMale     <- 0
sterAdultFemale   <- parameter_df[k, 'female_ster']
sterJuvMale       <- 0
sterJuvFemale     <- parameter_df[k, 'female_ster']
euthPuppyMale     <- 0
euthPuppyFemale   <- 0
euthAdultMale     <- 0
euthAdultFemale   <- 0
euthJuvMale       <- 0
euthJuvFemale     <- 0
boosterGiven <- TRUE
# inputs for management timing
mgtMonthVector     <- rep(0, 12)
mgtMonthVector[1]  <- 0
mgtMonthVector[2]  <- 0
mgtMonthVector[3]  <- 0
mgtMonthVector[4]  <- 1
mgtMonthVector[5]  <- 0
mgtMonthVector[6]  <- 0
mgtMonthVector[7]  <- 0
mgtMonthVector[8]  <- 0
mgtMonthVector[9]  <- 0
mgtMonthVector[10] <- 0
mgtMonthVector[11] <- 0
mgtMonthVector[12] <- 0
########################################################################################################################
########################################################################################################################
# Misc preliminary calculations and assignments:
# Get total number of days in simulation:
simulationEnd   <- 365 * simulationYears
# A vector of month number for use in seasonal timing:
monthSeries <- c(rep(1, 31), rep(2, 28), rep(3, 31), rep(4, 30),
rep(5, 31), rep(6, 30), rep(7, 31), rep(8, 31),
rep(9, 30), rep(10, 31), rep(11, 30), rep(12, 31))
monthFirstDays <- rep(c(match(1, monthSeries), match(2, monthSeries), match(3, monthSeries), match(4, monthSeries),
match(5, monthSeries), match(6, monthSeries), match(7, monthSeries), match(8, monthSeries),
match(9, monthSeries), match(10, monthSeries), match(11, monthSeries), match(12, monthSeries)),
simulationYears)
# Get days of each year that disease will be introduced:
pressureMonths <- seq(monthInitIntroduction, monthInitIntroduction + monthsOfPressure - 1)
pressureYears <- (pressureMonths - 1) %/% 12 + 1
pressureDays <- list()
for (i in 1:simulationYears) {
if (sum(pressureYears == i) > 0) {
pressureDays[[i]] <- monthFirstDays[pressureMonths[pressureYears == i]]
} else {
pressureDays[[i]] <- 0
}
}
flush.console()
# Calculate demographics of initial population:
initialAdults     <- round(initialFracAdult * initialPopSize)
initialSubAdults  <- initialPopSize - initialAdults
initialPuppies    <- round(initialFracPup * initialSubAdults)
initialJuveniles  <- initialSubAdults - initialPuppies
# Calculate daily mortality probabilities:
pupMortalityProb   <- 1 - (1 - pupAnnMortProb) ^ (1/365)
juvMortalityProb   <- 1 - (1 - juvAnnMortProb) ^ (1/365)
adultMortalityProb <- 1 - (1 - adultAnnMortProb) ^ (1/365)
# Calculate daily litter probabilities:
monthDayCount <- c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
if(sum(birthPulseVector) != 12 & sum(birthPulseVector != 0)) {
peakDays <- sum(birthPulseVector * monthDayCount)
peakProb <- (fractionBirthPulse * expLitterPer) / peakDays
offPeakDays <- sum((!birthPulseVector) * monthDayCount)
offPeakProb <- ((1-fractionBirthPulse) * expLitterPer) / offPeakDays
litterProbability <- rep(offPeakProb, 365)
for(m in 1:12) {
if(birthPulseVector[m] == 1) {
litterProbability[monthSeries == m] <- peakProb
}
}
} else {
litterProbability <- rep(expLitterPer / 365, 365)
}
# Calculate marginal costs of contact:
marginalCost1 <- contactCost25 / (initialPopSize * 0.25)
marginalCost2 <- contactCost50 / (initialPopSize * 0.25)
marginalCost3 <- contactCost75 / (initialPopSize * 0.25)
marginalCost4 <- contactCost100 / (initialPopSize * 0.25)
marginalCost <- c(marginalCost1, marginalCost2, marginalCost3, marginalCost4)
# List days that management will occur:
mgtDayVector <- rep(0, 365)
for(m in 1:12) {
if(mgtMonthVector[m] == 1) {
mgtDayVector[monthSeries == m] <- 1
}
}
managementDays <- seq(1, 365)
managementDays <- managementDays[mgtDayVector == 1]
# A list of traits in the population matrix:
traitList <- c('age', 'puppy', 'adult','female',
'sterilized', 'contracepted', 'timeContra',
'vaccinated', 'timeVacc',
'boosted', 'contacted', 'contactCost',
'exposed', 'timeExposed', 'timeLimitExposed',
'infective', 'timeInfective', 'timeLimitInfective',
'immune', 'month')
# A list of results that will be tracked:
censusSeries <- c('abundance', 'puppy', 'adult', 'females',
'sterilized', 'femalesSterilized',
'contracepted', 'femalesContracepted',
'vaccinated', 'immune', 'exposed', 'infective',
'PEPs', 'lifeLoss', 'newlyVaccinated')
censusVector <- rep(0, length(censusSeries))
names(censusVector) <- censusSeries
# Create a 3d array to store results:
resultsMatrix <- array(data=NA, dim=c(simulationEnd, length(censusSeries), iterations))
colnames(resultsMatrix) <- censusSeries
# Create a vector of binary strategy indicators:
strategyNames <- c('vaccPuppyMale', 'vaccPuppyFemale',
'vaccAdultMale', 'vaccAdultFemale',
'vaccJuvMale', 'vaccJuvFemale',
'contraPuppyMale', 'contraPuppyFemale',
'contraAdultMale', 'contraAdultFemale',
'contraJuvMale', 'contraJuvFemale',
'sterPuppyMale', 'sterPuppyFemale',
'sterAdultMale', 'sterAdultFemale',
'sterJuvMale', 'sterJuvFemale',
'euthPuppyMale', 'euthPuppyFemale',
'euthAdultMale', 'euthAdultFemale',
'euthJuvMale', 'euthJuvFemale')
strategyVector <- c(vaccPuppyMale, vaccPuppyFemale,
vaccAdultMale, vaccAdultFemale,
vaccJuvMale, vaccJuvFemale,
contraPuppyMale, contraPuppyFemale,
contraAdultMale, contraAdultFemale,
contraJuvMale, contraJuvFemale,
sterPuppyMale, sterPuppyFemale,
sterAdultMale, sterAdultFemale,
sterJuvMale, sterJuvFemale,
euthPuppyMale, euthPuppyFemale,
euthAdultMale, euthAdultFemale,
euthJuvMale, euthJuvFemale)
names(strategyVector) <- strategyNames
# Create a cost vector to indicate unit cost of each strategy:
strategyCostVector <- c(rep(vaccineCost, 6),
contraceptionCostMale, contraceptionCostFemale,
contraceptionCostMale, contraceptionCostFemale,
contraceptionCostMale, contraceptionCostFemale,
sterilizationCostMale, sterilizationCostFemale,
sterilizationCostMale, sterilizationCostFemale,
sterilizationCostMale, sterilizationCostFemale,
rep(euthanasiaCost, 6))
names(strategyCostVector) <- strategyNames
########################################################################################################################
########################################################################################################################
# Loop through iterations:
for(i in 1:iterations) {
print(paste('Running iteration', i))
flush.console()
popMatrix <- InitialPopulation()
# Loop through years:
for(j in 1:simulationYears) {
# reset total spending, number of dogs contacted, and contacted indicator at start of year
totalSpending <- 0
totalContacted <- 0
popMatrix[, 'contacted'] <- 0
# get the daily budget for each day of year
dailyBudget <- getDailyBudget(j)
# Loop through days of the year
for(d in 1:365) {
popMatrix[, 'month'] <- monthSeries[d]
resultsMatrix[(365 * (j-1) + d), ,i] <- CensusFunction()
popMatrix <- MortalityFunction()
popMatrix <- ReproductionFunction(d)
popMatrix <- ImmigrationFunction()
popMatrix <- DiseaseProgressionFunction()
popMatrix <- DiseaseSpreadFunction()
tempVacc <- sum(popMatrix[, 'vaccinated'])
if (totalSpending < annualBudget[j]) {
mgtReturnList <- ManagementFunction(d, marginalCost, dailyBudget, totalSpending, totalContacted)
popMatrix <- mgtReturnList[[1]]
totalContacted <- mgtReturnList[[2]]
totalSpending <- totalSpending + mgtReturnList[[3]]
}
# Record new vaccinations:
resultsMatrix[(365 * (j-1) + d), 'newlyVaccinated', i] <- sum(popMatrix[, 'vaccinated']) - tempVacc
popMatrix <- TimeFunction()
}  # close d for loop
}  # close j for loop
}  # close i for loop
########################################################################################################################
########################################################################################################################
# to access resultsMatrix:
#   resultsMatrix[day, results series, iteration]
# getting means across iterations:
meanResults <- matrix(NA, nrow=simulationEnd, ncol=length(censusSeries))
for(i in 1:simulationEnd) {
for(j in 1:length(censusSeries)) {
meanResults[i, j] <- mean(resultsMatrix[i, j, ], na.rm=TRUE)
}
}
########################################################################################################################
########################################################################################################################
# get some key results
#resultsMatrix[day, results series, iteration]
dogDaysOfInfection   <- sum(apply(resultsMatrix[, 'infective', ], 1, mean, na.rm=TRUE))
meanAbundance        <- mean(apply(resultsMatrix[, 'abundance', ], 1, mean, na.rm=TRUE))
totalCostOfInfection <- sum(apply(resultsMatrix[, 'PEPs', ], 1, mean, na.rm=TRUE))*costPerPEP
totalHumanDeaths     <- sum(apply(resultsMatrix[, 'lifeLoss', ], 1, mean, na.rm=TRUE))
totalBudget          <- sum(annualBudget[1:simulationYears])
totalVaccinations    <- sum(apply(resultsMatrix[, 'newlyVaccinated', ], 1, mean, na.rm=TRUE))
vaccPercentage       <- max(apply(resultsMatrix[, 'vaccinated', ] / resultsMatrix[, 'abundance', ],
1, mean, na.rm=TRUE))
# resultsMatrix[, 'infective', ] is a matrix with rows=days and columns=iterations
# get max prevalence by iteration:
# meanAbundance
maxPrev <- apply(resultsMatrix[, 'infective', ], 2, max, na.rm=TRUE)
parameter_df[k, 'dog_days'] <- round(dogDaysOfInfection, 2)
#mean(maxPrev)
parameter_df[k, 'prob_outbreak'] <- round(sum(maxPrev > 1)/iterations * 100)
parameter_df[k, 'max_prev'] <- round(mean(maxPrev[maxPrev > 1]), 2)
#totalVaccinations
parameter_df[k, 'max_vacc'] <- round(vaccPercentage * 100)
parameter_df[k, 'total_cost'] <- round(totalBudget + totalCostOfInfection)
#totalHumanDeaths
#install.packages("beepr")
#library(beepr)
########################################################################################################################
}
write.csv(parameter_df, 'Manuscript_Scenarios_Cost.csv')
beep(2)
